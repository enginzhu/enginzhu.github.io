---
layout: post
title: 读书笔记-《编码的奥妙》
comments: true
categories: 笔记
tags: reading-notes
---

## 现代通信的开端

在19世纪以前，人们要远程通信，只能用信件，通过马车，火车或者轮船去实现。加快这种通信速度的聪明一点的办法，也只是通过一堆人接力，用旗语去传递一些简单的消息。文字和声音是最直接被人接受的消息来源，但即时通信的同时却不能远距离通信。

人们想到了将语言翻译成可以被解释的代码，最早实现这种编码的是一个失明少年**路易斯·布莱叶**（`Louis Braille`），他发明了方便盲人阅读的**布莱叶编码**。后来**塞缪尔·莫尔斯**（`Samuel Morse`）创造性地发明了**摩斯密码**，**摩斯密码**的精髓就在于它是一种二元编码（`binary code`），由点和划两种信号组成（**为什么说创造性？因为别人还在一直为表达26个字母而设计极其复杂的设备**）。

**莫尔斯**原本是一位颇有成就的画家，为了实现远距离传递消息，他花费了大量时间和精力做设计和试验，导致生活极度贫困，最终利用电磁感应发明了电报机，并于1844年在华盛顿国会大厦成功地演示了电报机通信，将信息发送到了64公里以外的另一个城市。

## 二进制编码

也许最常见的二进制表现形式是**UPC**（`Universal Product Code`），即所有商品包装上都有的**条形码**。由黑色竖条和白色间隙组成的条形码，记载了一串连续的**比特位**（`bit`）。**竖条和间隙的宽度代表了有多少个连续的比特位**，起始的3个比特位固定为101，称为**左护线**，它帮助扫描器定位，并定义了该条形码中单个比特的宽度。

接着是6组比特串，每组7个比特位，代表一个0-9的数字，使用奇校验（即保证1的个数为奇数），并以0开头，以1结尾，如果扫描器发现一个数字不是以0开头或者以1结尾，则说明条形码没有被正确读取或者被篡改。7个比特位保证只有两组连续的值为1的序列，也就是说每个数字对应了两块黑色竖条。

接着是固定编码为01010的内置检错码，称为**中间护线**（`center guard pattern`，也是为了防止篡改和错印）。中间护线后紧接着的同样是6组比特串，与前面6组不同的是使用偶校验。最后是固定为101的**右护线**（使**UPC**支持反向扫描）。

因此，**UPC**最终解码后是12个十进制数字，代表了商品类型，产家等信息，而最后一位是模校验字符（`我随手拿了身边一些条形码计算校验码，发现并不匹配，而且下面的数字有13个，与书上写的不符合。查找相关资料后，发现是EAN-13条形码，是UPC经由欧洲国家发展出来的商品条码版本`）

## 逻辑电路的渊源

早在公元前4世纪，古希腊人就认为逻辑是追寻真理的过程中分析语言的一种手段，那个时候就已经有著名的三段论了。**亚里士多德**（`Aristotle`）的逻辑学就是建立在三段论的基础上。

此后的两千多年，数学家们苦苦思索，试图将**亚里士多德**的逻辑理论用数学符号和操作符来表达出来。而19世纪以前，唯一能接近这个目标的是**莱布尼茨**（`Leibniz`）。莱布尼茨早年涉及逻辑学，后来将精力转向其他学科，例如与牛顿同时创造出微积分。

接下来有所突破的是**乔治·布尔**（`George Boole`，1815-1864），布尔将逻辑转化成可以用数学符号表达的系统，称之为**布尔代数**（`Boolean algebra`）。布尔代数中参与表达式运算的不是数字，而是**集合**（`set`）。

然而乔治·布尔到死也没有想过可以用开关，电线和灯泡来连接一个电路实现一个**布尔表达式**。那个时候虽然白炽灯还没有发明（直到布尔死后15年），但**莫尔斯**在1844年已经演示了电报发声器，电路中的灯泡完全可以用电报发声器替代。

整个19世纪，没有人将布尔代数中的AND，OR与串联，并联的一些开关联系起来，数学家没有，电工没有，电报操作员也没有，甚至计算机革命的创始人-**查尔斯·巴贝奇（`Charles Babbage`，1792-1871）**也没有（此人早年开发出差分机用来求解对数和三角函数，之后大半生都致力于开发分析机，期间失去政府支持，受尽冷眼嘲笑，直到晚年不能准确地发音，甚至不能有条理地表达自己的意思依然坚持工作，然而因为**分析机的设想超出了那个时代至少一个世纪**，最终不可避免地失败）。

一直到了20世纪30年代，这种联系才被人发现，主要的贡献人是**克劳德·香农**（`Claude Elwood Shannon`，1916-2001）。


## 逻辑门

最基础的4个逻辑门：**与门**（`AND gate`），**或门**（`OR gate`），**与非门**（`NAND gate`），**或非门**（`NOR gate`），它们都由继电器（`relay`）组成，下图是它们的**真值表**（`truth table`）：
![logic gates]({{ site.url }}/image/code-note/logic-gates.png)

具有反向输入端的与门，功能等同于或非门；具有反向输入端的或门，功能等同于与非门，这两对等同的电路实际上就是**德摩根定律**（`De Morgan's Laws`）的内容。

电气工程中还有另外两个逻辑门：**异或门**（`XOR gate`），**同或门**（`Coincidence gate`）。另外还有**反相器**（`inverter` 输入与输出相反），**缓冲器**（`buffer` 输入等于输出，弱信号下有延迟功能）。


## 如何实现一个8位二进制加法器

最简单的加法是两个比特相加（两个加数只能是1或0），将加法拆成两个电路实现，每个电路都有2个输入端，当输入这两个比特时，一个电路输出**和**（`sum`），另一个电路输出**进位**（`carry`）。

进位电路**真值表**：

|进位|0|1|
|--|--|
|0|0|0|
|1|0|1|

求和电路**真值表**：

|和|0|1|
|--|--|
|0|0|1|
|1|1|0|

进位电路的真值表和与门完全一致，可以用与门电路实现进位输出，求和电路的真值表则和异或门一样，加法可以用这两种电路实现。至此构成的是一个**半加器**（`half adder`），输入为两个二进制比特，输出为进位与和。

然而大多二进制数并不止一个比特，半加器并不能处理多位二进制数的加法，因为高位数的相加还需考虑低位数运算带来的进位。要在电路上添加一个进位输入，需要**两个半加器和一个或门**，构成一个**全加器**（`full adder`）。而8个全加器就可以组成一个8位二进制加法机，该电路总共需要144个继电器。同样地，两个8位加法机就可以组成一个16位二进制加法机。

这种加法器电路中，高位数的加法计算总是需要等待上一步低位数计算的进位作为输入，越是高位延迟越大，因此**加法器的总体速度 = 加数的位数 * 单个全加器的速度**。这种进位方式称为**行波进位**（`ripple carry`），而更快的加法器则使用称为**先行进位**（`look-ahead carry`）的加法电路。

## 如何实现减法电路

计算机使用**2的补码**（`two's complement`，台湾称为二补数）来表示负数，计算方式为原始数取反后加一。如果将原始数取反而不加一，结果则称为是**1的补码**（`ones' complement`）。减法运算可以转化为被减数（`minuend`）加上减数（`subtrahend`）的二补数，用补数计算结果可以避免做减法，从而使整个计算用加法电路就可以完成。

计算**1的补码**的电路，可以将8个反相器封装起来，输入8位数就可以输出它的补码。
![eight inverters]({{ site.url }}/image/code-note/eight-inverters.png)
如果希望通过一个输入开关控制是否取反（减法需要取反，加法不需要取反），可以使用8个异或门集成到一个盒子里，称为**求补器**（`ones' complement`）。
![ones complement]({{ site.url }}/image/code-note/ones-complement.png)

在8位运算中，当被减数大于减数时，结果为正数，第9位的进位输出永远是1，表示最后的结果要减去`10000000`，当被减数小于减数，结果为负数，第9位的进位输出为0，标识下溢，结果是一个补码表示形式。

8位加法器加上一个加/减法输入开关（用作求补器的输入，加法器的进位输入），还有一个求补器就可以实现对加减法运算的同时支持。


## 存储电路的实现

将继电器和电源连接成一个回路，回路中有一个金属簧片开关，继电器通电时会吸引簧片断开电路，断电后继电器中的电磁铁失去磁性，金属簧片回到原来位置又构成通电回路，电路在高电平和低电平之间来回切换，不需要人为干涉就能自主工作，这种电路称为**振荡器**（`oscillator`），蜂鸣器和电铃就是振荡器实现的。振荡器有时也称为**时钟**（`clock`）。

两个或非门，两个开关，一个灯泡可以组成如下电路：
![trigger]({{ site.url }}/image/code-note/trigger.png)
与振荡器类似，输出用作另一个地方的输入，这是一种**反馈**（`feedback`）。该电路有两个稳定状态，称为**触发器**（`flip-flop`）。触发器具有记忆，可以保存信息。最简单的触发器是**R-S触发器**。

在R-S触发器的基础上实现时钟信号控制功能，称为**电平触发的D型锁存器**（`level-triggered D-type latch`），D是Data的缩写。只有时钟信号触发时，触发器才保存数据端的输入，时钟信号为0时，输出端不受数据端影响，保持不变，直到下一次信号触发。该电路也称为**1位存储器**。

8个锁存器可以组成一个8位锁存器，8位锁存器可以存储一个8位数，将它与8位加法器组合协作，可以将加法结果储存起来，实现多个8位数的累加，用于累加的锁存器称为**累加器**（`accumulator`）。

**2-1选择器**（`2 to 1 Selector`）可以用开关控制从两个输入端中选择其中一个作为输出。同理，有8个数据输入端，3个地址输入端和1个输出端，则称为**8-1选择器**。

对于一个8位锁存器，在其输出端接上一个8-1选择器，可以通过控制地址线选择某一位数据的读取（3个地址开关的状态组合正好可以表示8位二进制地址值，即000-111），而在其输入端接一个**3-8译码器**（`3 to 8 Decoder`），同样地，通过地址线可以控制向8位锁存器中的某一位写入数据，用来在存储器中寻址。这就是我们通常所说的**随机访问存储器（RAM）**。

RAM具有数据易失性，断电后存储器中所有的继电器都将会失去磁性，存储的内容也将永远消失。
